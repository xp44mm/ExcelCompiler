module ExcelCompiler.ExcelDFA
let nextStates = Map [0u,Map ["%",42u;"&",36u;"(",8u;")",29u;"*",39u;"+",37u;",",10u;"-",38u;"/",40u;"<",32u;"<=",33u;"<>",31u;"=",30u;">",34u;">=",35u;"APOSTROPHE",13u;"DOLLAR",19u;"ERROR",26u;"FALSE",27u;"ID",6u;"INTEGER",21u;"NEGATIVE",2u;"NUMBER",24u;"POSITIVE",1u;"QUOTE",25u;"TRUE",28u;"[",45u;"]",46u;"^",41u;"{",43u;"}",44u];1u,Map ["INTEGER",3u;"NUMBER",5u];2u,Map ["INTEGER",3u;"NUMBER",5u];3u,Map [":",4u];6u,Map ["!",18u;"(",7u;":",15u];8u,Map [",",9u];10u,Map [")",12u;",",11u];13u,Map ["!",18u;":",14u];14u,Map ["APOSTROPHE",16u;"ID",16u];15u,Map ["APOSTROPHE",16u;"DOLLAR",23u;"ID",17u;"INTEGER",23u];16u,Map ["!",18u];17u,Map ["!",18u];18u,Map ["DOLLAR",19u;"ID",19u;"INTEGER",20u];19u,Map [":",22u];20u,Map [":",22u];21u,Map [":",22u];22u,Map ["DOLLAR",23u;"ID",23u;"INTEGER",23u]]
let lexemesFromFinal = Map [4u,set [1u;2u];7u,set [6u];9u,set [8u];11u,set [10u];12u,set [10u]]
let universalFinals = set [1u;2u;3u;4u;5u;6u;7u;8u;9u;10u;11u;12u;17u;19u;21u;23u;24u;25u;26u;27u;28u;29u;30u;31u;32u;33u;34u;35u;36u;37u;38u;39u;40u;41u;42u;43u;44u;45u;46u]
let indicesFromFinal = Map [1u,29;2u,30;3u,1;4u,0;5u,1;6u,6;7u,2;8u,14;9u,3;10u,13;11u,4;12u,5;17u,6;19u,6;21u,7;23u,6;24u,8;25u,9;26u,10;27u,11;28u,12;29u,15;30u,16;31u,17;32u,18;33u,19;34u,20;35u,21;36u,22;37u,23;38u,24;39u,25;40u,26;41u,27;42u,28;43u,31;44u,32;45u,33;46u,34]
open FSharpCompiler.Analyzing
let analyzer = LexicalAnalyzer( nextStates, lexemesFromFinal, universalFinals, indicesFromFinal )